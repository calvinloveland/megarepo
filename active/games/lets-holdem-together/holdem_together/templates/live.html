{% extends 'base.html' %}

{% block title %}Live Match ‚Äî Hold 'Em Together{% endblock %}

{% block content %}
<div class="live-container">
  <!-- TV Broadcast Header -->
  <div class="broadcast-header">
    <div class="broadcast-logo">
      <span class="live-indicator">‚óè LIVE</span>
      <span class="broadcast-title">Hold 'Em Together Championship</span>
    </div>
    <div class="broadcast-controls">
      {% if saved_username and user_bots %}
      <button class="btn btn-find-my-bot" onclick="findMyBot()">
        üîç Find My Bot
      </button>
      {% endif %}
      <span id="total-tables-info">{{ num_tables }} table{% if num_tables != 1 %}s{% endif %}</span>
    </div>
  </div>

  <!-- Table Navigation -->
  <div class="table-nav" id="table-nav">
    {% for i in range(num_tables) %}
    <button class="table-tab {% if i == 0 %}active{% endif %}" data-table-id="{{ i }}" onclick="switchToTable({{ i }})">
      Table {{ i + 1 }}
      <span class="table-status" id="table-status-{{ i }}">‚è≥</span>
    </button>
    {% endfor %}
  </div>

  <!-- User's bot indicator (hidden by default) -->
  <div class="my-bot-indicator" id="my-bot-indicator" style="display: none;">
    <span class="my-bot-icon">‚≠ê</span>
    <span id="my-bot-text">Your bot is playing here!</span>
  </div>

  <!-- Main Poker Table (shows selected table) -->
  <div class="poker-table-container" id="main-table-container">
    <div class="poker-table" id="poker-table-main">
      <!-- Pot Display -->
      <div class="pot-display">
        <div class="pot-label">POT</div>
        <div class="pot-amount" id="pot-amount">0</div>
      </div>

      <!-- Community Cards -->
      <div class="community-cards" id="community-cards">
        <div class="playing-card card-placeholder"></div>
        <div class="playing-card card-placeholder"></div>
        <div class="playing-card card-placeholder"></div>
        <div class="playing-card card-placeholder"></div>
        <div class="playing-card card-placeholder"></div>
      </div>

      <!-- Player Seats (positioned around the table) -->
      <div class="player-seats" id="player-seats">
        <!-- Players will be injected here by JavaScript -->
      </div>

      <!-- Dealer Button -->
      <div class="dealer-button" id="dealer-button" style="display: none;">D</div>
    </div>
  </div>

  <!-- Mini Tables Overview -->
  <div class="mini-tables-container" id="mini-tables-container">
    <div class="mini-tables-header">
      <span>üì∫ All Tables Overview</span>
      <span class="mini-tables-hint">Click a table to watch</span>
    </div>
    <div class="mini-tables-grid" id="mini-tables-grid">
      {% for i in range(num_tables) %}
      <div class="mini-table" id="mini-table-{{ i }}" onclick="switchToTable({{ i }})">
        <div class="mini-table-header">
          <span class="mini-table-title">Table {{ i + 1 }}</span>
          <span class="mini-table-status" id="mini-status-{{ i }}">Starting...</span>
        </div>
        <div class="mini-table-felt" id="mini-felt-{{ i }}">
          <div class="mini-players" id="mini-players-{{ i }}"></div>
          <div class="mini-pot" id="mini-pot-{{ i }}">ü™ô 0</div>
        </div>
      </div>
      {% endfor %}
    </div>
  </div>

  <!-- Action Log / Commentary -->
  <div class="commentary-panel">
    <div class="commentary-header">
      <span>üì∫ Live Commentary - <span id="commentary-table-label">Table 1</span></span>
      <span class="auto-play-badge">AUTO-PLAY</span>
    </div>
    <div class="commentary-log" id="commentary-log">
      <div class="commentary-entry welcome">
        Welcome to Hold 'Em Together Live! 
        {% if available_bots >= 2 %}
          {{ num_tables }} table{% if num_tables != 1 %}s{% endif %} running with {{ available_bots }} bots ‚Äî sit back and enjoy the show!
        {% else %}
          <span class="error-text">Need at least 2 valid bots to start a match. Create some bots first!</span>
        {% endif %}
      </div>
    </div>
  </div>

  <!-- Final Standings Panel (hidden initially) -->
  <div class="standings-panel" id="standings-panel" style="display: none;">
    <div class="winner-celebration" id="winner-celebration">
      <div class="winner-trophy">üèÜ</div>
      <div class="winner-title">CHAMPION!</div>
      <div class="winner-name" id="winner-name"></div>
      <div class="winner-user" id="winner-user"></div>
      <div class="winner-chips" id="winner-chips"></div>
    </div>
    <div class="standings-header">Final Standings</div>
    <div class="standings-list" id="standings-list"></div>
    <div class="next-match-notice" id="next-match-notice">
      Next match starting in <span id="countdown">8</span>s...
    </div>
  </div>
  
  <!-- Confetti Canvas -->
  <canvas id="confetti-canvas"></canvas>
  
  <!-- Hand Winner Popup -->
  <div class="hand-winner-popup" id="hand-winner-popup" style="display: none;">
    <div class="hand-winner-content">
      <span class="hand-winner-icon">üèÜ</span>
      <span class="hand-winner-text" id="hand-winner-text"></span>
    </div>
  </div>
</div>

<script>
// Configuration
const NUM_TABLES = {{ num_tables }};
const USER_BOT_IDS = {{ user_bots | tojson }};
const SAVED_USERNAME = {{ saved_username | tojson }};

// Card rendering utilities
const SUIT_SYMBOLS = {'c': '‚ô£', 'd': '‚ô¶', 'h': '‚ô•', 's': '‚ô†'};
const SUIT_COLORS = {'c': '#2d5016', 'd': '#0066cc', 'h': '#cc0000', 's': '#1a1a1a'};

function renderCard(cardStr) {
  if (!cardStr || cardStr.length < 2) return '<div class="playing-card card-back"></div>';
  const rank = cardStr[0];
  const suit = cardStr[1];
  const symbol = SUIT_SYMBOLS[suit] || suit;
  const color = SUIT_COLORS[suit] || '#000';
  const displayRank = rank === 'T' ? '10' : rank;
  return `<div class="playing-card card-front" style="color: ${color}">
    <span class="card-rank">${displayRank}</span>
    <span class="card-suit">${symbol}</span>
  </div>`;
}

function renderCardBack() {
  return '<div class="playing-card card-back"></div>';
}

// Player seat positions for different player counts
const SEAT_POSITIONS = {
  2: [{x: 50, y: 90}, {x: 50, y: 10}],
  3: [{x: 50, y: 90}, {x: 15, y: 30}, {x: 85, y: 30}],
  4: [{x: 50, y: 90}, {x: 10, y: 50}, {x: 50, y: 10}, {x: 90, y: 50}],
  5: [{x: 50, y: 90}, {x: 10, y: 60}, {x: 20, y: 15}, {x: 80, y: 15}, {x: 90, y: 60}],
  6: [{x: 50, y: 92}, {x: 8, y: 65}, {x: 8, y: 25}, {x: 50, y: 5}, {x: 92, y: 25}, {x: 92, y: 65}]
};

// State for all tables
let tableStates = {};
let eventSources = {};
let activeTableId = 0;

// Initialize state for each table
for (let i = 0; i < NUM_TABLES; i++) {
  tableStates[i] = {
    players: [],
    stacks: [],
    pot: 0,
    handNum: 0,
    status: 'waiting',
    hasUserBot: false
  };
}

function createPlayerSeats(tableId, playersInfo, startingStack) {
  tableStates[tableId].players = playersInfo;
  tableStates[tableId].stacks = playersInfo.map(() => startingStack);
  
  // Check if user's bot is at this table
  const userBotAtTable = playersInfo.find(p => USER_BOT_IDS.includes(p.bot_id));
  tableStates[tableId].hasUserBot = !!userBotAtTable;
  
  // Update mini table players list
  updateMiniTablePlayers(tableId, playersInfo);
  
  // If this is the active table, render to main view
  if (tableId === activeTableId) {
    renderMainTable(tableId, startingStack);
    
    // Show "my bot" indicator if applicable
    if (userBotAtTable) {
      showMyBotIndicator(userBotAtTable.name);
    } else {
      hideMyBotIndicator();
    }
  }
  
  // Update table tab to show user's bot indicator
  if (userBotAtTable) {
    const tab = document.querySelector(`.table-tab[data-table-id="${tableId}"]`);
    if (tab && !tab.querySelector('.my-bot-star')) {
      const star = document.createElement('span');
      star.className = 'my-bot-star';
      star.textContent = '‚≠ê';
      star.title = `Your bot "${userBotAtTable.name}" is here`;
      tab.appendChild(star);
    }
  }
}

function renderMainTable(tableId, startingStack) {
  const playersInfo = tableStates[tableId].players;
  const container = document.getElementById('player-seats');
  container.innerHTML = '';
  
  const positions = SEAT_POSITIONS[playersInfo.length] || SEAT_POSITIONS[6];
  
  playersInfo.forEach((p, i) => {
    const pos = positions[i] || {x: 50, y: 50};
    const seat = document.createElement('div');
    seat.className = 'player-seat';
    seat.id = `seat-${i}`;
    seat.style.left = `${pos.x}%`;
    seat.style.top = `${pos.y}%`;
    
    const isUserBot = USER_BOT_IDS.includes(p.bot_id);
    const userBotClass = isUserBot ? ' my-bot' : '';
    
    seat.innerHTML = `
      <div class="player-cards" id="cards-${i}">
        ${renderCardBack()}${renderCardBack()}
      </div>
      <div class="player-info${userBotClass}">
        ${isUserBot ? '<span class="my-bot-badge">‚≠ê</span>' : ''}
        <div class="player-name">${p.name}</div>
        <div class="player-user">by ${p.user}</div>
        <div class="player-stack" id="stack-${i}">ü™ô ${startingStack}</div>
      </div>
      <div class="player-action" id="action-${i}"></div>
      <div class="player-bet" id="bet-${i}"></div>
    `;
    
    container.appendChild(seat);
  });
}

function updateMiniTablePlayers(tableId, playersInfo) {
  const container = document.getElementById(`mini-players-${tableId}`);
  if (!container) return;
  
  let html = '';
  playersInfo.forEach(p => {
    const isUserBot = USER_BOT_IDS.includes(p.bot_id);
    html += `<div class="mini-player${isUserBot ? ' my-bot' : ''}">${p.name.substring(0, 8)}</div>`;
  });
  container.innerHTML = html;
}

function updateStacks(tableId, stacks) {
  tableStates[tableId].stacks = stacks;
  
  if (tableId === activeTableId) {
    stacks.forEach((stack, i) => {
      const el = document.getElementById(`stack-${i}`);
      if (el) {
        el.textContent = `ü™ô ${stack}`;
        el.className = 'player-stack' + (stack === 0 ? ' busted' : '');
      }
    });
  }
}

function setDealer(tableId, seat) {
  if (tableId !== activeTableId) return;
  
  const players = tableStates[tableId].players;
  const btn = document.getElementById('dealer-button');
  const positions = SEAT_POSITIONS[players.length] || SEAT_POSITIONS[6];
  const pos = positions[seat];
  if (pos && btn) {
    btn.style.display = 'flex';
    btn.style.left = `${pos.x + 5}%`;
    btn.style.top = `${pos.y + 3}%`;
  }
}

function showAction(tableId, seat, actionType, amount) {
  if (tableId !== activeTableId) return;
  
  const el = document.getElementById(`action-${seat}`);
  if (!el) return;
  
  let text = actionType.toUpperCase();
  let className = 'player-action';
  
  switch(actionType) {
    case 'fold':
      className += ' action-fold';
      break;
    case 'check':
      className += ' action-check';
      break;
    case 'call':
      text = `CALL ${amount || ''}`;
      className += ' action-call';
      break;
    case 'raise':
      text = `RAISE TO ${amount || ''}`;
      className += ' action-raise';
      break;
    case 'post_sb':
      text = `SB ${amount}`;
      className += ' action-blind';
      break;
    case 'post_bb':
      text = `BB ${amount}`;
      className += ' action-blind';
      break;
    default:
      text = `${actionType.toUpperCase()} ${amount || ''}`.trim();
  }
  
  el.className = className + ' show';
  el.textContent = text;
  
  // Clear after delay
  setTimeout(() => {
    el.className = 'player-action';
  }, 2000);
}

function clearAllActions(tableId) {
  if (tableId !== activeTableId) return;
  
  const players = tableStates[tableId].players;
  players.forEach((_, i) => {
    const el = document.getElementById(`action-${i}`);
    if (el) {
      el.className = 'player-action';
      el.textContent = '';
    }
  });
}

function updateCommunityCards(tableId, cards) {
  if (tableId !== activeTableId) return;
  
  const container = document.getElementById('community-cards');
  let html = '';
  
  // Show dealt cards
  cards.forEach(card => {
    html += renderCard(card);
  });
  
  // Fill remaining with placeholders
  for (let i = cards.length; i < 5; i++) {
    html += '<div class="playing-card card-placeholder"></div>';
  }
  
  container.innerHTML = html;
}

function resetCommunityCards(tableId) {
  if (tableId !== activeTableId) return;
  
  const container = document.getElementById('community-cards');
  container.innerHTML = `
    <div class="playing-card card-placeholder"></div>
    <div class="playing-card card-placeholder"></div>
    <div class="playing-card card-placeholder"></div>
    <div class="playing-card card-placeholder"></div>
    <div class="playing-card card-placeholder"></div>
  `;
}

function revealHoleCards(tableId, holeCards) {
  if (tableId !== activeTableId) return;
  
  holeCards.forEach((cards, seat) => {
    const el = document.getElementById(`cards-${seat}`);
    if (el && cards && cards.length === 2) {
      el.innerHTML = renderCard(cards[0]) + renderCard(cards[1]);
    }
  });
}

function hideAllHoleCards(tableId) {
  if (tableId !== activeTableId) return;
  
  const players = tableStates[tableId].players;
  players.forEach((_, i) => {
    const el = document.getElementById(`cards-${i}`);
    if (el) {
      el.innerHTML = renderCardBack() + renderCardBack();
    }
  });
}

function markFolded(tableId, seat) {
  if (tableId !== activeTableId) return;
  
  const seatEl = document.getElementById(`seat-${seat}`);
  if (seatEl) {
    seatEl.classList.add('folded');
  }
}

function clearFolded(tableId) {
  if (tableId !== activeTableId) return;
  
  const players = tableStates[tableId].players;
  players.forEach((_, i) => {
    const seatEl = document.getElementById(`seat-${i}`);
    if (seatEl) seatEl.classList.remove('folded');
  });
}

function highlightWinners(tableId, winners) {
  if (tableId !== activeTableId) return;
  
  winners.forEach(seat => {
    const seatEl = document.getElementById(`seat-${seat}`);
    if (seatEl) {
      seatEl.classList.add('winner');
    }
  });
}

function clearWinnerHighlight(tableId) {
  if (tableId !== activeTableId) return;
  
  const players = tableStates[tableId].players;
  players.forEach((_, i) => {
    const seatEl = document.getElementById(`seat-${i}`);
    if (seatEl) seatEl.classList.remove('winner');
  });
}

function updatePot(tableId, amount) {
  tableStates[tableId].pot = amount;
  
  // Update mini table pot
  const miniPot = document.getElementById(`mini-pot-${tableId}`);
  if (miniPot) {
    miniPot.textContent = `ü™ô ${amount}`;
  }
  
  if (tableId === activeTableId) {
    document.getElementById('pot-amount').textContent = amount;
  }
}

function addCommentary(tableId, message, type = 'normal') {
  if (tableId !== activeTableId) return;
  
  const log = document.getElementById('commentary-log');
  const entry = document.createElement('div');
  entry.className = `commentary-entry ${type}`;
  entry.innerHTML = message;
  log.appendChild(entry);
  log.scrollTop = log.scrollHeight;
}

function clearCommentary() {
  const log = document.getElementById('commentary-log');
  log.innerHTML = '';
}

function updateTableStatus(tableId, status) {
  tableStates[tableId].status = status;
  
  const statusEl = document.getElementById(`table-status-${tableId}`);
  const miniStatusEl = document.getElementById(`mini-status-${tableId}`);
  
  let emoji = '‚è≥';
  let text = status;
  
  switch(status) {
    case 'playing':
      emoji = 'üé¥';
      text = `Hand ${tableStates[tableId].handNum}`;
      break;
    case 'complete':
      emoji = 'üèÜ';
      text = 'Complete';
      break;
    case 'error':
      emoji = '‚ùå';
      break;
    default:
      emoji = '‚è≥';
  }
  
  if (statusEl) statusEl.textContent = emoji;
  if (miniStatusEl) miniStatusEl.textContent = text;
}

function showStandings(tableId, standings, winner) {
  if (tableId !== activeTableId) return;
  
  const panel = document.getElementById('standings-panel');
  const list = document.getElementById('standings-list');
  
  // Show winner celebration
  if (winner) {
    document.getElementById('winner-name').textContent = winner.name;
    document.getElementById('winner-user').textContent = `by ${winner.user}`;
    const sign = winner.chips_won >= 0 ? '+' : '';
    document.getElementById('winner-chips').textContent = `${sign}${winner.chips_won} chips`;
  }
  
  let html = '';
  standings.forEach((s, i) => {
    const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `#${i+1}`;
    const chipsClass = s.chips_won >= 0 ? 'chip-positive' : 'chip-negative';
    const sign = s.chips_won >= 0 ? '+' : '';
    html += `
      <div class="standing-row ${i === 0 ? 'first-place' : ''}">
        <span class="standing-rank">${medal}</span>
        <span class="standing-name">${s.name}</span>
        <span class="standing-chips ${chipsClass}">${sign}${s.chips_won}</span>
      </div>
    `;
  });
  
  list.innerHTML = html;
  panel.style.display = 'block';
}

function showHandWinnerPopup(tableId, winnerName, amount) {
  if (tableId !== activeTableId) return;
  
  const popup = document.getElementById('hand-winner-popup');
  const text = document.getElementById('hand-winner-text');
  text.textContent = `${winnerName} wins ${amount}!`;
  popup.style.display = 'flex';
  
  setTimeout(() => {
    popup.style.display = 'none';
  }, 2500);
}

function showMyBotIndicator(botName) {
  const indicator = document.getElementById('my-bot-indicator');
  const text = document.getElementById('my-bot-text');
  text.textContent = `Your bot "${botName}" is playing at this table!`;
  indicator.style.display = 'flex';
}

function hideMyBotIndicator() {
  document.getElementById('my-bot-indicator').style.display = 'none';
}

// Confetti animation
function launchConfetti() {
  const canvas = document.getElementById('confetti-canvas');
  const ctx = canvas.getContext('2d');
  
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  canvas.style.display = 'block';
  
  const confettiCount = 150;
  const confetti = [];
  const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffd700', '#ff6b35'];
  
  for (let i = 0; i < confettiCount; i++) {
    confetti.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height - canvas.height,
      w: Math.random() * 10 + 5,
      h: Math.random() * 6 + 4,
      color: colors[Math.floor(Math.random() * colors.length)],
      speed: Math.random() * 3 + 2,
      angle: Math.random() * Math.PI * 2,
      spin: (Math.random() - 0.5) * 0.2,
      drift: (Math.random() - 0.5) * 2
    });
  }
  
  let frame = 0;
  const maxFrames = 300;
  
  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    confetti.forEach(c => {
      ctx.save();
      ctx.translate(c.x + c.w/2, c.y + c.h/2);
      ctx.rotate(c.angle);
      ctx.fillStyle = c.color;
      ctx.fillRect(-c.w/2, -c.h/2, c.w, c.h);
      ctx.restore();
      
      c.y += c.speed;
      c.x += c.drift;
      c.angle += c.spin;
    });
    
    frame++;
    if (frame < maxFrames) {
      requestAnimationFrame(animate);
    } else {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      canvas.style.display = 'none';
    }
  }
  
  animate();
}

function hideStandings() {
  document.getElementById('standings-panel').style.display = 'none';
  const canvas = document.getElementById('confetti-canvas');
  if (canvas) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    canvas.style.display = 'none';
  }
  document.getElementById('hand-winner-popup').style.display = 'none';
}

function switchToTable(tableId) {
  if (tableId === activeTableId) return;
  
  // Update active state
  const oldTab = document.querySelector(`.table-tab[data-table-id="${activeTableId}"]`);
  const newTab = document.querySelector(`.table-tab[data-table-id="${tableId}"]`);
  if (oldTab) oldTab.classList.remove('active');
  if (newTab) newTab.classList.add('active');
  
  // Update mini table highlights
  const oldMini = document.getElementById(`mini-table-${activeTableId}`);
  const newMini = document.getElementById(`mini-table-${tableId}`);
  if (oldMini) oldMini.classList.remove('active');
  if (newMini) newMini.classList.add('active');
  
  activeTableId = tableId;
  
  // Update commentary label
  document.getElementById('commentary-table-label').textContent = `Table ${tableId + 1}`;
  
  // Refresh main table display
  const state = tableStates[tableId];
  if (state.players.length > 0) {
    renderMainTable(tableId, 1000);
    updateStacks(tableId, state.stacks);
    updatePot(tableId, state.pot);
    
    if (state.hasUserBot) {
      const userBot = state.players.find(p => USER_BOT_IDS.includes(p.bot_id));
      if (userBot) showMyBotIndicator(userBot.name);
    } else {
      hideMyBotIndicator();
    }
  }
  
  // Hide standings when switching tables
  hideStandings();
  clearCommentary();
  addCommentary(tableId, `üì∫ Switched to Table ${tableId + 1}`, 'important');
}

function findMyBot() {
  // Find first table with user's bot
  for (let i = 0; i < NUM_TABLES; i++) {
    if (tableStates[i].hasUserBot) {
      switchToTable(i);
      return;
    }
  }
  
  // If no table found yet, show message
  alert('Your bot is not currently playing. Tables are still initializing or your bot may not be submitted.');
}

function startTableStream(tableId) {
  // Close existing connection for this table
  if (eventSources[tableId]) {
    eventSources[tableId].close();
  }
  
  let runningPot = 0;
  
  eventSources[tableId] = new EventSource(`/live/stream/${tableId}`);
  
  eventSources[tableId].onmessage = function(event) {
    const data = JSON.parse(event.data);
    
    switch(data.type) {
      case 'init':
        createPlayerSeats(tableId, data.players, data.starting_stack);
        updateTableStatus(tableId, 'playing');
        addCommentary(tableId, `üé≤ <strong>${data.players.length} players</strong> at Table ${tableId + 1}!`, 'important');
        data.players.forEach(p => {
          addCommentary(tableId, `Seat ${p.seat}: <strong>${p.name}</strong> by ${p.user}`);
        });
        break;
      
      case 'hole_cards':
        revealHoleCards(tableId, data.hole_cards);
        addCommentary(tableId, 'üÇ¥ Cards dealt! Let\'s see what everyone has...', 'board');
        break;
        
      case 'new_hand':
        tableStates[tableId].handNum = data.hand_num;
        clearFolded(tableId);
        clearWinnerHighlight(tableId);
        hideAllHoleCards(tableId);
        resetCommunityCards(tableId);
        clearAllActions(tableId);
        runningPot = 0;
        updatePot(tableId, 0);
        setDealer(tableId, data.dealer_seat);
        updateStacks(tableId, data.stacks);
        updateTableStatus(tableId, 'playing');
        
        const players = tableStates[tableId].players;
        addCommentary(tableId, `<hr><strong>üÉè Hand ${data.hand_num}</strong> ‚Äî Dealer: ${players[data.dealer_seat]?.name || 'Seat ' + data.dealer_seat}`, 'hand-start');
        break;
        
      case 'board':
        updateCommunityCards(tableId, data.cards);
        const streetName = data.street.charAt(0).toUpperCase() + data.street.slice(1);
        if (data.street === 'flop') {
          addCommentary(tableId, `üé¥ <strong>FLOP:</strong> ${data.cards.map(c => (c[0] === 'T' ? '10' : c[0]) + (SUIT_SYMBOLS[c[1]] || c[1])).join(' ')}`, 'board');
        } else {
          const lastCard = data.cards[data.cards.length - 1];
          addCommentary(tableId, `üé¥ <strong>${streetName.toUpperCase()}:</strong> ${(lastCard[0] === 'T' ? '10' : lastCard[0])}${SUIT_SYMBOLS[lastCard[1]] || lastCard[1]}`, 'board');
        }
        break;
        
      case 'action':
        showAction(tableId, data.seat, data.action_type, data.amount);
        
        if (data.amount && ['call', 'raise', 'post_sb', 'post_bb'].includes(data.action_type)) {
          runningPot += data.amount;
          updatePot(tableId, runningPot);
        }
        
        let actionText = '';
        switch(data.action_type) {
          case 'fold':
            actionText = `${data.player} <span class="action-text fold">FOLDS</span>`;
            markFolded(tableId, data.seat);
            break;
          case 'check':
            actionText = `${data.player} <span class="action-text check">checks</span>`;
            break;
          case 'call':
            actionText = `${data.player} <span class="action-text call">CALLS ${data.amount}</span>`;
            break;
          case 'raise':
            actionText = `${data.player} <span class="action-text raise">RAISES to ${data.amount}</span> üî•`;
            break;
          case 'post_sb':
            actionText = `${data.player} posts small blind (${data.amount})`;
            break;
          case 'post_bb':
            actionText = `${data.player} posts big blind (${data.amount})`;
            break;
          default:
            actionText = `${data.player} ${data.action_type} ${data.amount || ''}`;
        }
        addCommentary(tableId, actionText);
        break;
        
      case 'showdown':
        revealHoleCards(tableId, data.hole_cards);
        addCommentary(tableId, 'üëÅÔ∏è <strong>SHOWDOWN!</strong> Cards revealed...', 'showdown');
        break;
        
      case 'hand_result':
        highlightWinners(tableId, data.winners);
        updateStacks(tableId, data.final_stacks);
        
        const winnerNames = data.winner_names || data.winners.map(s => tableStates[tableId].players[s]?.name || `Seat ${s}`);
        const totalPot = data.total_pot || data.delta_stacks.filter(d => d > 0).reduce((a, b) => a + b, 0);
        showHandWinnerPopup(tableId, winnerNames.join(' & '), totalPot);
        
        addCommentary(tableId, `üèÜ <strong>${winnerNames.join(' & ')}</strong> wins ${totalPot} chips!`, 'winner');
        break;
        
      case 'match_complete':
        addCommentary(tableId, '<hr>üéä <strong>MATCH COMPLETE!</strong>', 'important');
        showStandings(tableId, data.standings, data.winner);
        updateTableStatus(tableId, 'complete');
        
        if (tableId === activeTableId) {
          launchConfetti();
        }
        
        eventSources[tableId].close();
        
        // Restart this table after countdown
        setTimeout(() => {
          startTableStream(tableId);
        }, 8000);
        break;
        
      case 'error':
        addCommentary(tableId, `‚ùå Error: ${data.message}`, 'error');
        updateTableStatus(tableId, 'error');
        eventSources[tableId].close();
        setTimeout(() => startTableStream(tableId), 5000);
        break;
    }
  };
  
  eventSources[tableId].onerror = function(e) {
    console.error(`Table ${tableId} EventSource error:`, e);
    updateTableStatus(tableId, 'error');
    eventSources[tableId].close();
    setTimeout(() => startTableStream(tableId), 3000);
  };
}

function startAllTables() {
  // Reset UI
  hideStandings();
  clearCommentary();
  document.getElementById('pot-amount').textContent = '0';
  
  addCommentary(0, 'üé¨ <strong>Starting all tables!</strong>', 'important');
  
  // Start all table streams with slight delay between each
  for (let i = 0; i < NUM_TABLES; i++) {
    setTimeout(() => {
      startTableStream(i);
    }, i * 500); // Stagger starts by 500ms
  }
}

// Clean up on page unload
window.addEventListener('beforeunload', function() {
  for (let i = 0; i < NUM_TABLES; i++) {
    if (eventSources[i]) {
      eventSources[i].close();
    }
  }
});

// Auto-start on page load
{% if available_bots >= 2 %}
window.addEventListener('DOMContentLoaded', function() {
  // Set first mini-table as active
  const firstMini = document.getElementById('mini-table-0');
  if (firstMini) firstMini.classList.add('active');
  
  // Small delay to let page render
  setTimeout(startAllTables, 500);
});
{% endif %}
</script>
{% endblock %}
