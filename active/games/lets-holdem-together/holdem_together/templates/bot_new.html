{% extends 'base.html' %}

{% block title %}New bot â€” Hold 'Em Together{% endblock %}

{% block content %}
  <div class="bot-create-form">
    <h3 style="text-align: center;">Create a bot</h3>
    <form method="post" class="card">
      <div class="row">
        <label>User name<br />
          <input name="user_name" placeholder="your_name" value="{{ saved_username or '' }}" />
        </label>
        <label>Bot name<br />
          <input name="bot_name" placeholder="my_bot" />
        </label>
      </div>
      <div style="margin-top: 12px;">
        <label>Code</label>
        <div id="code-status" class="code-status checking">Checking code...</div>
        <textarea id="code-editor" name="code">def decide_action(game_state: dict) -> dict:
    """
    Decide what action to take based on the current game state.
    
    Args:
        game_state: Dictionary containing all game information
        
    Returns:
        dict with 'type' key: 'fold', 'check', 'call', or 'raise'
        For 'raise', also include 'amount' key with integer value
    """
    # Get hand strength info
    hand = game_state["hand_strength"]
    equity = hand["equity_estimate"]  # 0.0 to 1.0
    
    # Simple strategy: play strong hands
    if equity > 0.7:
        return {"type": "raise", "amount": game_state["pot"]}
    elif equity > 0.4:
        return {"type": "call"}
    else:
        return {"type": "check"}
</textarea>
    </div>
    <div class="row" style="margin-top: 12px;">
      <button class="btn" type="submit">Create</button>
    </div>
  </form>

  <!-- Help Panel -->
  <div class="help-panel">
    <h4>ðŸ“– Bot Development Guide</h4>
    <p class="muted">Your bot must define a <code>decide_action(game_state: dict) -> dict</code> function.</p>

    <div class="collapsible">
      <div class="collapsible-header" onclick="toggleCollapsible(this)">â–¶ Game State Reference</div>
      <div class="collapsible-content">
        <table class="game-state-ref">
          <tr><td><code>game_state["hole_cards"]</code></td><td>Your cards, e.g. <code>["Ah", "Kd"]</code></td></tr>
          <tr><td><code>game_state["board_cards"]</code></td><td>Community cards, e.g. <code>["Ts", "Jc", "Qh"]</code></td></tr>
          <tr><td><code>game_state["street"]</code></td><td><code>"preflop"</code>, <code>"flop"</code>, <code>"turn"</code>, or <code>"river"</code></td></tr>
          <tr><td><code>game_state["pot"]</code></td><td>Current pot size (integer)</td></tr>
          <tr><td><code>game_state["stacks"]</code></td><td>List of stack sizes per seat</td></tr>
          <tr><td><code>game_state["actor_seat"]</code></td><td>Your seat number</td></tr>
          <tr><td><code>game_state["legal_actions"]</code></td><td>List of valid actions you can take</td></tr>
          <tr><td><code>game_state["hand_strength"]["category"]</code></td><td>e.g. <code>"pair"</code>, <code>"flush"</code>, <code>"straight"</code></td></tr>
          <tr><td><code>game_state["hand_strength"]["equity_estimate"]</code></td><td>Win probability (0.0 to 1.0)</td></tr>
          <tr><td><code>game_state["contributed_this_street"]</code></td><td>Chips each player put in this street</td></tr>
          <tr><td><code>game_state["contributed_total"]</code></td><td>Total chips each player has put in</td></tr>
          <tr><td><code>game_state["action_history"]</code></td><td>List of previous actions in this hand</td></tr>
        </table>
      </div>
    </div>

    <div class="collapsible">
      <div class="collapsible-header" onclick="toggleCollapsible(this)">â–¶ Return Values</div>
      <div class="collapsible-content">
        <p>Your function must return a dictionary with a <code>"type"</code> key:</p>
        <ul>
          <li><code>{"type": "fold"}</code> â€” Give up the hand</li>
          <li><code>{"type": "check"}</code> â€” Pass (when no bet to call)</li>
          <li><code>{"type": "call"}</code> â€” Match the current bet</li>
          <li><code>{"type": "raise", "amount": 100}</code> â€” Raise to specified amount</li>
        </ul>
      </div>
    </div>

    <div class="collapsible">
      <div class="collapsible-header" onclick="toggleCollapsible(this)">â–¶ Example: Tight-Aggressive Bot</div>
      <div class="collapsible-content">
<pre>def decide_action(game_state: dict) -> dict:
    equity = game_state["hand_strength"]["equity_estimate"]
    pot = game_state["pot"]
    my_stack = game_state["stacks"][game_state["actor_seat"]]
    
    # Premium hands: raise aggressively
    if equity > 0.75:
        raise_amt = min(pot * 2, my_stack)
        return {"type": "raise", "amount": int(raise_amt)}
    
    # Good hands: call or small raise
    elif equity > 0.55:
        if pot < my_stack // 4:
            return {"type": "raise", "amount": pot}
        return {"type": "call"}
    
    # Marginal hands: check or fold
    elif equity > 0.35:
        return {"type": "check"}
    
    # Weak hands: fold
    return {"type": "fold"}</pre>
      </div>
    </div>

    <div class="collapsible">
      <div class="collapsible-header" onclick="toggleCollapsible(this)">â–¶ Example: Position-Aware Bot</div>
      <div class="collapsible-content">
<pre>def decide_action(game_state: dict) -> dict:
    equity = game_state["hand_strength"]["equity_estimate"]
    street = game_state["street"]
    actor = game_state["actor_seat"]
    dealer = game_state["dealer_seat"]
    
    # Check if we're in late position (near dealer)
    num_players = len(game_state["stacks"])
    position = (actor - dealer) % num_players
    in_position = position >= num_players - 2
    
    # Play looser in position
    threshold = 0.4 if in_position else 0.5
    
    if equity > threshold + 0.2:
        return {"type": "raise", "amount": game_state["pot"]}
    elif equity > threshold:
        return {"type": "call"}
    elif street == "preflop" and in_position:
        return {"type": "call"}  # See more flops in position
    
    return {"type": "check"}</pre>
      </div>
    </div>

    <div class="collapsible">
      <div class="collapsible-header" onclick="toggleCollapsible(this)">â–¶ Example: Bluffing Bot</div>
      <div class="collapsible-content">
<pre>import random

def decide_action(game_state: dict) -> dict:
    equity = game_state["hand_strength"]["equity_estimate"]
    pot = game_state["pot"]
    street = game_state["street"]
    
    # Value bet strong hands
    if equity > 0.7:
        return {"type": "raise", "amount": int(pot * 0.75)}
    
    # Semi-bluff draws on flop/turn
    if street in ["flop", "turn"] and 0.3 < equity < 0.5:
        if random.random() < 0.3:  # Bluff 30% of the time
            return {"type": "raise", "amount": int(pot * 0.5)}
    
    # Call with decent hands
    if equity > 0.4:
        return {"type": "call"}
    
    return {"type": "check"}</pre>
      </div>
    </div>
  </div>
  </div>

  <script>
    // Initialize CodeMirror
    var textarea = document.getElementById('code-editor');
    var editor = CodeMirror.fromTextArea(textarea, {
      mode: 'python',
      theme: 'monokai',
      lineNumbers: true,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      matchBrackets: true,
      autoCloseBrackets: true,
      extraKeys: {
        "Tab": function(cm) {
          cm.replaceSelection("    ", "end");
        }
      }
    });

    // Code validation
    var statusEl = document.getElementById('code-status');
    var checkTimeout = null;

    function validateCode() {
      var code = editor.getValue();
      statusEl.className = 'code-status checking';
      statusEl.textContent = 'Checking code...';

      var issues = [];

      // Check for decide_action function
      if (!/def\s+decide_action\s*\(/.test(code)) {
        issues.push('Missing function: decide_action(game_state)');
      }

      // Check for return statement
      if (!/return\s+\{/.test(code) && !/return\s+{"type"/.test(code)) {
        issues.push('Missing return statement with dict');
      }

      // Check for basic syntax issues
      var lines = code.split('\n');
      var openParens = 0, openBrackets = 0, openBraces = 0;
      for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        // Skip comments
        var commentIdx = line.indexOf('#');
        if (commentIdx >= 0) line = line.substring(0, commentIdx);
        
        for (var j = 0; j < line.length; j++) {
          var c = line[j];
          if (c === '(') openParens++;
          if (c === ')') openParens--;
          if (c === '[') openBrackets++;
          if (c === ']') openBrackets--;
          if (c === '{') openBraces++;
          if (c === '}') openBraces--;
        }
      }
      
      if (openParens !== 0) issues.push('Unbalanced parentheses ()');
      if (openBrackets !== 0) issues.push('Unbalanced brackets []');
      if (openBraces !== 0) issues.push('Unbalanced braces {}');

      // Check for common action return values
      if (!/(fold|check|call|raise)/.test(code)) {
        issues.push('No action type found (fold/check/call/raise)');
      }

      // Update status
      if (issues.length === 0) {
        statusEl.className = 'code-status valid';
        statusEl.textContent = 'âœ“ Code looks valid';
      } else {
        statusEl.className = 'code-status invalid';
        statusEl.textContent = 'âš  ' + issues.join(' â€¢ ');
      }
    }

    editor.on('change', function() {
      clearTimeout(checkTimeout);
      checkTimeout = setTimeout(validateCode, 500);
    });

    // Initial validation
    validateCode();

    // Collapsible sections
    function toggleCollapsible(header) {
      var content = header.nextElementSibling;
      var isOpen = content.classList.contains('open');
      content.classList.toggle('open');
      header.textContent = (isOpen ? 'â–¶ ' : 'â–¼ ') + header.textContent.substring(2);
    }
  </script>
{% endblock %}
